/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.18 fish.glb -o /home/ziga/misc/DesignFundamentals/src/models/finsh.jsx 
*/

import * as THREE from 'three';
import React, { useRef, useEffect } from 'react'
import fishScene from '../assets/3d/fish.glb';
import { useGLTF, useAnimations } from '@react-three/drei'
import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';
import { useGraph, useFrame } from '@react-three/fiber';
import { useMemo } from 'react';


export function Model({ initialRotation, ...props }) {
  const fishRef = useRef()
  const { scene, animations } = useGLTF(fishScene)
  const copiedScene = useMemo(() => SkeletonUtils.clone(scene), [scene]);
  const { nodes, materials } = useGraph(copiedScene);
  const { actions } = useAnimations(animations, fishRef)
  useEffect(() => {
    fishRef.initialPosition = fishRef.current.position;
    // Play the swimming animation if it exists
    actions.Animation.play();

    // fishRef.current.rotation.y = initialRotation;
  }, [actions, initialRotation]);


  useFrame((state) => {
    const speed = 0.05;
    const maxDistance = 30;

    // calculate the distance between initial position and current position
    const distance = fishRef.current.position.distanceTo(new THREE.Vector3(0, 0, 0));
    console.log('distance:', distance);
    if (distance > maxDistance) {
      // const rot = fishRef.current.rotation;
      // // turn around
      // fishRef.current.rotation.set(- rot.x, - rot.y, - rot.z);
      fishRef.current.rotation.y += Math.PI;
    }

    const direction = new THREE.Vector3(0, 0, 1);
    direction.applyQuaternion(fishRef.current.quaternion);

    fishRef.current.position.add(direction.multiplyScalar(speed));


    // let rotation = fishRef.current.rotation;
    // console.log('rotation:', rotation);
    // let rotationVector = new THREE.Vector3().fromArray(rotation);
    // if (rotationVector.length() < 0.1) {
    //   rotationVector = new THREE.Vector3(0, 0, 1);
    // }
    // rotationVector.normalize();
    // console.log('rotation after:', rotationVector);
    // console.log('position:', fishRef.current.position.toArray());
    // const direction = rotationVector.multiplyScalar(speed);

    // fishRef.current.position.add(direction);
    // // sleep for a second
    // setTimeout(() => {
    //   fishRef.current.position.add(direction);
    // }, 1000);


    // fishRef.current.position.y = Math.sin(state.clock.elapsedTime * 2) * 2;
  });


  return (
    <group ref={fishRef} {...props} dispose={null}>
      <group name="Scene">
        <group name="Armature" position={[0.017, -0.029, 0.474]} rotation={[1.521, 0.161, 3.119]}>
          <group name="defaultMaterial" position={[-0.002, 0.472, -0.055]} rotation={[1.521, 0.031, 2.982]} />
          <primitive object={nodes.Bone} />
          <primitive object={nodes.Bone002} />
          <skinnedMesh name="defaultMaterial001" geometry={nodes.defaultMaterial001.geometry} material={materials.initialShadingGroup} skeleton={nodes.defaultMaterial001.skeleton} />
        </group>
      </group>
    </group>

  )
}

useGLTF.preload(fishScene)
